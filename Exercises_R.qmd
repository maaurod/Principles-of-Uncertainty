---
title: "R Exercises"
author: "Mauro Diaz"
format: html
editor: visual
execute:
  echo: true
  warning: true
  error: true
---
# Chapter 1
## Exercise 1.9
A standard deck (52 cards) is distributed to two persons: 26 cards to each person. All partitions are equally likely. Find the probability that:
    
    a) The first person gets 4 Queens.
    
    b) The first person gets at least 2 Queens.

R) Use simulation (sample) to check the above answers.


```{r}
set.seed(1)

cards <- 1:52 # creates a vector with the element 1 to 52
n     <- 10000 # number of samples

# SINTAXIS: vector is used for creating empy vectors of a specific type (mode)
q4    <- vector(mode = "logical", length = n)
q2    <- vector(mode = "logical", length = n)

for (i in 1:n) {
  p1      <- sample(cards, 26) # sample of 26 elements in the vector of the cards
  q4[i]   <- sum(1:4 %in% p1) == 4 # sum of the elements 1 to 4 that are present in the sample
  q2[i]   <- sum(1:4 %in% p1) >= 2
}
sum(q4) / n # sum(q4) sums the elements in TRUE.
sum(q2) / n
```
## Exercise 1.10

Let A and B be events with probabilities:$ P(A) = 2 / 3, \quad P(B) = 1/2.$
    
    a) Show that $\tfrac{1}{6} \le P(A \cap B) \le \tfrac{1}{2},$ and give examples to show that both extremes are possible.
    
    b)  Find corresponding bounds for ( P(A \cup B) ).
    
    R) Draw samples from the examples and show the probability bounds of ( $P(A \cap B)$ ).

Fair die: $\Omega = \{ 1, \dots, 6\}$ and $A = \{3, 4, 5, 6\}$, $B = \{1, 2, 3\}$ for the lower bound and $A = B + {4}$ for the upper bound
```{r}
set.seed(1)

n <- 10000
a_l <- 3:6
a_u <- 1:4
b <- 1:3

samples <- sample(1:6, n, replace = TRUE)

lb     <- vector(mode = "logical", length = n)
ub     <- vector(mode = "logical", length = n)

for (i in 1:n) {
  lb[i] <- samples[i] %in% a_l & samples[i] %in% b
  ub[i] <- samples[i] %in% a_u & samples[i] %in% b
}
sum(lb) / n
sum(ub) / n
```
# Chapter 2
## Exercise 2.8

Take the measure space $ (\Omega_1 = (0,1], \mathcal{B}(0,1], \lambda) $ where we know that this is a probability space on ((0,1]).

    a) Define a map (function) $f : \Omega_1 \to \Omega_2 = {1, 2, 3, 4, 5, 6}$ such that the measure space $ (\Omega_2, 2^{\Omega_2}, \lambda(f^{-1}(\cdot))) $ is a discrete probability space with uniform probabilities, i.e.,$P(\omega) = \tfrac{1}{6}, \quad \forall \omega \in \Omega_2. $


R) Use the map in (a) as a basis for a random generator for this fair die.

```{r}
set.seed(1)

n <- 1000
# Generate 1000 numbers from the Omega_1 space uniformly
unif_s <- runif(n)

# for every number, calculate the mapping with f
die_s  <- ceiling(6 * unif_s)

# as.factor converts the elements in categories and summary counts the number of elem in each category
summary(as.factor(die_s)) / n
```
# Chapter 3
## Exercise 3.2
Consider tossing a fair die. Let A = {2, 4, 6} and B = {1, 2, 3, 4}.  
Then P(A) = 1/2, P(B) = 2/3 and P(AB) = 1/3.  
Since P(AB) = P(A)P(B), the events A and B are independent.  

Simulate draws from the sample space and verify that the proportions are the same.  
Then find two events C and D that are **not independent** and repeat the simulation.
```{r}
set.seed(1)
n <- 1000
a <- c(2, 4, 6)
b <- 1:4
ab <- c(2, 4)
c <- c(1)
d <- 1:2
samples <- sample(1:6, n, replace=TRUE)

as     <- vector(mode = "logical", length = n)
bs     <- vector(mode = "logical", length = n)
abs     <- vector(mode = "logical", length = n)

for (i in 1:n) {
  as[i] <- samples[i] %in% a
  bs[i] <- samples[i] %in% b
  abs[i] <- samples[i] %in% ab
}
sum(as) * sum(bs) / n**2
sum(abs) / n

```
```{r}
set.seed(1)
n <- 1000
c <- c(1)
d <- 1:2
cd <- c(1)
samples <- sample(1:6, n, replace=TRUE)

cs     <- vector(mode = "logical", length = n)
ds     <- vector(mode = "logical", length = n)
cds     <- vector(mode = "logical", length = n)

for (i in 1:n) {
  cs[i] <- samples[i] %in% c
  ds[i] <- samples[i] %in% d
  cds[i] <- samples[i] %in% cd
}
sum(cs) * sum(ds) / n**2
sum(cds) / n

```
## Exercise 3.3
A machine reports the true value of a thrown 12-sided die 5 out of 6 times.  

    a) If the machine reports a 1 has been tossed, what is the probability that it is actually a 1?

    b) Now let the machine only report whether a 1 has been tossed or not. Does the probability change?

R) Use simulation to check your answers to a) and b).

We will do only a) to practice
```{r}
set.seed(1)  
nsamps <- 10000 

report_a <- numeric(nsamps)   # Machine's reported number (1–12)
report_b <- logical(nsamps)   # Whether machine reports "1" (TRUE/FALSE)
truths   <- logical(nsamps)   # Whether the machine was correct (TRUE = correct report)

for (i in 1:nsamps) {
  
  # Toss the real die (true outcome)
  toss <- sample(1:12, size = 1)
  
  # Step 2: Determine whether the machine reports correctly
  truth <- sample(c(TRUE, FALSE), size = 1, prob = c(5/6, 1/6))
  truths[i] <- truth   # Store whether this report is truthful
  
  if (truth) {
    report_a[i] <- toss           # Machine says the true number
    report_b[i] <- toss == 1      # Machine says "1" only if true toss is 1
  } else {
    # The machine chooses a random *different* number
    remaining <- (1:12)[1:12 != toss]    # All numbers except the true one
    report_a[i] <- sample(remaining, 1)  # Pick one wrong number uniformly
    
    # If the toss wasn't 1, this means machine says “not 1” correctly here
    report_b[i] <- toss != 1
  }
}
# Select all cases where the machine *reported a 1*
truth_a1 <- truths[report_a == 1]
sum(truth_a1) / length(truth_a1)
truth_b1 <- truths[report_b]
sum(truth_b1) / length(truth_b1)
```
## Exercise 3.4
A coin is tossed independently n times. The probability of heads at each toss is p.  
At each time k (k = 2, 3, ..., n) we get a reward at time k+1 if the k-th toss was a head and the previous toss was a tail.  
Let Aₖ be the event that a reward is obtained at time k.
  
    a) Are events Aₖ and Aₖ₊₁ independent?
    
    b) Are events Aₖ and Aₖ₊₂ independent?

R) Simulate 10 tosses 10,000 times, where p = 0.7.  
Check your answers to a) and b) by counting the frequencies of the events A₅, A₆, and A₇.
```{r}
set.seed(1)
n <- 10000
p = 0.7

a5 <- vector(mode = "logical", n)
a6 <- vector(mode = "logical", n)
a7 <- vector(mode = "logical", n)
a56 <- vector(mode = "logical", n)
a57 <- vector(mode = "logical", n)

for (i in 1:n) {
  samples <- sample(1:2, 10, replace=TRUE, prob = c(p, (1 - p)))
  a5[i] <- (samples[4] == 1 & samples[3] == 2)
  a6[i] <- (samples[5] == 1 & samples[4] == 2)
  a7[i] <- (samples[6] == 1 & samples[5] == 2)
  a56[i] <- (a5[i] & a6[i])
  a57[i] <- (a5[i] & a7[i])
}

sum(a5) / n
sum(a6) / n
sum(a56) / n
sum(a7) / n
sum(a5) * sum(a7) / n**2
sum(a57) / n

``` 
## Exercise 3.6
Exercise 3.6  
Judy goes around the company for Women’s Day and shares flowers.  
In every office she leaves a flower if there is at least one woman inside.  
The probability that there’s a woman in the office is 3/5.

    a) What is the probability that Judy leaves her first flower in the fourth office?

    b) Given that she has given away exactly three flowers in the first four offices, what is the probability that she gives her fourth flower in the eighth office?

    c) What is the probability that she leaves the second flower in the fifth office?

    d) What is the probability that she leaves the second flower in the fifth office, given that she did not leave the second flower in the second office?

    e) Judy needs a new supply of flowers immediately after the office where she gives away her last flower.
       What is the probability that she visits at least five offices, if she starts with two flowers?

R) Simulate Judy’s walk 10,000 times to check your answers for a)–e).

```{r}
set.seed(1)
n <- 10000
p = 0.6
numoffices = 8

a <- vector(mode = "logical", n)
b <- vector(mode = "logical", n)
cond <- vector(mode = "logical", n)
c <- vector(mode = "logical", n)
cond2 <- vector(mode = "logical", n)
d <- vector(mode = "logical", n)
e <- vector(mode = "logical", n)

for (i in 1:n) {
  samples <- sample(0:1, numoffices, replace=TRUE, prob = c(1 - p, p))
  a[i] <- (samples[4] == 1 & all(samples[1:3] == 0))
  cond[i] <- sum(samples[1:4]) == 3
  b[i] <- (samples[8] == 1 & all(samples[5:7] == 0))
  c[i] <- (samples[5] == 1 & sum(samples[1:4]) == 1)
  cond2[i] <- (samples[2] == 0)
  d[i] <- (samples[5] == 1 & sum(samples[1:5]) == 2)
  e[i] <- (sum(samples[1:4]) < 2 & sum(samples) >= 2)
}

sum(a) / n
sum(b[cond]) / sum(cond) ## Conditional Probability (check why cond and why dividing by sum(cond))
sum(c) / n
sum(d[cond2]) / sum(cond2)
sum(e) / n

``` 
Cumsum and matrix way:
```{r}
set.seed(1)
nsamps     <- 100000
# initialize the matrix with NA values
Judyswalks <- matrix(data = NA, nrow = nsamps, ncol = 8)
for (i in 1:nsamps) {
  thiswalk <- sample(c(0,1), size = 8, replace = TRUE, prob = c(0.4, 0.6))
  Judyswalks[i, ] <- thiswalk
}
# apply means apply a function over (if 1 rows, if 2 columns) -> cumsum function
# cumsum the cumulative number of flowers left at the office i
# t is transpose because cumsum does it transpose, we want the original size
csJudy <- t(apply(Judyswalks, 1, cumsum))

# a
sum(csJudy[ ,4] == 1 & csJudy[ ,3] == 0) / nsamps
# b
csJsubset <- csJudy[csJudy[ ,4] == 3 & csJudy[ ,3] == 2, ]
sum(csJsubset[ ,8] == 4 & csJsubset[ ,7] == 3) / nrow(csJsubset)
# c
sum(csJudy[ ,5] == 2 & csJudy[ ,4] == 1) / nsamps
# d
sum(csJudy[ ,5] == 2 & csJudy[ ,4] == 1) / sum(csJudy[ ,2] != 2)
# e
sum(csJudy[ ,4] < 2) / nsamps
```

